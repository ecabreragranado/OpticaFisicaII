{"kernelspec":{"display_name":"Python 3","language":"python","name":"python3"},"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.4.3+"},"name":"Trenes de Onda.ipynb"}
{"cell_type":"markdown","metadata":{},"source":"# Experimento de Young con trenes de ondas"}
{"cell_type":"markdown","metadata":{},"source":"### Consideraciones iniciales"}
{"cell_type":"code","execution_count":11,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"image/png":"smc-blob::d0f82dc5-4c92-4012-8308-ab250af1432f","text/plain":"<IPython.core.display.Image object>"},"execution_count":11,"metadata":{},"output_type":"execute_result"}],"source":"from IPython.display import Image\nImage(filename=\"EsquemaYoung.png\")"}
{"cell_type":"markdown","metadata":{},"source":"Cuando estudiamos el experimento de Young, asumimos que iluminábamos con radiación monocromática. En este caso, la posición de los máximos y mínimos de irradiancia venían dados por, \n\n<div class=\"alert alert-error\">\nMáximos de irradiancia.  $\\delta = 2 m \\pi \\implies \\frac{a x}{D} = m \\implies$\n\n$$x_{max} = \\frac{m \\lambda D}{a}$$\n</div>\n<div class=\"alert alert-error\">\nMínimos de irradiancia.  $\\delta = (2 m + 1)\\pi \\implies \\frac{a x}{D} = (m +1/2) \\implies$\n\n$$x_{min} = \\frac{(m + 1/2) \\lambda D}{a}$$\n</div>\n\nComo vemos en las fórmulas anteriores, la posición de los máximos y mínimos dependen de la longitud de onda $\\lambda$. Cuando iluminamos el mismo experimento con radiación no monocromática, podemos considerar que cada longitud de onda que compone el espectro de la radiación forma su patrón de interferencias. Pero cada patrón de interferencias tendrá los máximos en posiciones ligeramente distintas. Esto va a llevar a una reducción del constraste y finalmente, a la desaparición de las franjas de interferencia. Vamos a estudiar este proceso con más detalle, viendo primero una mejor aproximación que una onda monocromática a la radiación que emiten la fuentes de luz reales, y posteriormente, cómo afecta este tipo de radiación a las interferencias en un experimento de Young"}
{"cell_type":"markdown","metadata":{},"source":"### Trenes de onda"}
{"cell_type":"markdown","metadata":{},"source":"Aunque la abstracción de tratar una onda monocromática es extremadamente útil, las fuentes de luz reales no emiten tal radiación. La razón es sencilla: una onda monocromática pura (es decir, un seno o un coseno) no tiene ni principio ni final, por lo que para emitir una onda de este tipo se necesitaría energía infinita.\n\nLo más próximo que podemos obtener a una onda monocromática es una sucesión de trenes de ondas armónicos separados unos de otros por saltos aleatorios en la fase de la onda. \n\nEl siguiente código muestra un ejemplo de este tipo de trenes de onda.  "}
{"cell_type":"code","execution_count":4,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"image/png":"smc-blob::de30324c-2dac-48be-a9c2-fd74455070ea","text/plain":"<matplotlib.figure.Figure at 0x7f741d2dacc0>"},"metadata":{},"output_type":"display_data"}],"source":"import matplotlib.pyplot as plt\nimport numpy as np\n%matplotlib inline\nplt.style.use('fivethirtyeight')\n#import ipywidgets as widg\n#from IPython.display import display\n\n#####\n#PARÁMETROS QUE SE PUEDEN MODIFICAR\n#####\nLambda = 5e-7\nc0 = 3e8\nomega = 2*np.pi*c0/Lambda\nT = 2*np.pi/omega\ntau = 2*T\n###########\n\n\ntime = np.linspace(0,18*T,600)\n\ndef campo(t,w,tau0):\n    numsaltos = (int)(np.floor(t[-1]/tau0))\n    phi = (np.random.random(numsaltos)-0.5)*4*np.pi\n    phi_aux = np.array([np.ones(np.size(t)/numsaltos)*phi[i] for i in range(numsaltos)])\n    phi_t = np.reshape(phi_aux,np.shape(phi_aux)[0]*np.shape(phi_aux)[1])\n    phi_t = np.pad(phi_t,(np.size(t)-np.size(phi_t),0),mode='edge')\n    e1 = np.cos(omega*t + phi_t)\n    fig,ax = plt.subplots(1,1,figsize=(8,4))\n    ax.plot(t,e1)\n    ax.set_xlabel('Tiempo (s)')\n    ax.set_ylabel('Campo (u.a.)')\n    return None\n\ncampo(time,omega,tau)"}
{"cell_type":"markdown","metadata":{},"source":"### Longitud de coherencia\n\nEl tiempo en el que la fase de la onda permanece constante (tiempo entre saltos consecutivos) se llama **tiempo de coherencia** y nosotros lo denominaremos $t_c$. \n\nSi observamos el tren de ondas espacialmente, veremos una figura similar a la anterior, es decir, una figura sinusoidal con un periodo igual a la longitud de onda $\\lambda$ y con saltos de fase cada cierta distancia. A esta distancia se le denomina **longitud de coherencia** ($l_c$) y se relaciona con el tiempo de coherencia mediante la relación, \n\n$$l_c = c t_c$$\n\ndonde $c$ es la velocidad de la luz. "}
{"cell_type":"markdown","metadata":{},"source":"### Anchura espectral\n\nUn tren de ondas deja de ser una radiación completamente monocromática, es decir, con una única longitud de onda o frecuencia, pasando a tener una cierta anchura espectral. Lo podemos entender observando que un tren de ondas deja de ser un coseno o un seno debido a esos saltos de fase aleatorios, pasando a tener una evolución temporal más compleja. \n\nLa anchura en frecuencias (o longitudes de onda) de un tren de ondas la podemos hallar mediante la transformada de Fourier. Este análisis queda fuera del objeto de este curso pero sí nos vas a resultar útil un resultado que emerge de esta transformada: la relación entre anchura espectral (rango de frecuencias presentes en la radiación $\\Delta \\nu$) y tiempo de coherencia. Esta relación es, \n\n$$t_c \\simeq \\frac{1}{\\Delta \\nu}$$\n\nTeniendo en cuenta que $\\nu = c/\\lambda$ podemos llegar a la relación entre la longitud de coherencia y la anchura espectral expresada en longitudes de onda, \n\n$$l_c \\simeq \\frac{\\lambda^2}{\\Delta \\lambda}$$\n\nLa anterior relación nos dice que a mayor longitud de coherencia, menor anchura espectral de la radiación, o lo que es lo mismo, más monocromática será. "}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"image/png":"smc-blob::7ece08f7-1f5c-4333-b688-6588eb2018ba","text/plain":"<matplotlib.figure.Figure at 0x7f75100b9d68>"},"metadata":{},"output_type":"display_data"}],"source":"import matplotlib.pyplot as plt\nimport numpy as np\n%matplotlib inline\nplt.style.use('fivethirtyeight')\nimport ipywidgets as widg\nfrom IPython.display import display\n\n#####\n#PARÁMETROS QUE SE PUEDEN MODIFICAR\n#####\nLambda = 5e-7\nc0 = 3e8\nomega = 2*np.pi*c0/Lambda\nT = 2*np.pi/omega\ntime = np.linspace(0,30*T,1500)\ntau = 2*T\n###########\ndef campofft(t,w,tau0):\n    numsaltos = (int)(np.floor(t[-1]/tau0))\n    phi = (np.random.random(numsaltos)-0.5)*4*np.pi\n    phi_aux = np.array([np.ones(np.size(t)/numsaltos)*phi[i] for i in range(numsaltos)])\n    phi_t = np.reshape(phi_aux,np.shape(phi_aux)[0]*np.shape(phi_aux)[1])\n    phi_t = np.pad(phi_t,(np.size(t)-np.size(phi_t),0),mode='edge')\n    e1 = np.cos(omega*t + phi_t)\n    fig1,ax1 = plt.subplots(1,2,figsize=(10,4))\n    ax1[0].plot(t,e1)\n    ax1[0].set_title('Campo')\n    ax1[0].set_xlabel('tiempo (s)')\n    ax1[1].set_ylabel('E(t)')\n    freq = np.fft.fftfreq(t.shape[0],t[1]-t[0])\n    e1fft = np.fft.fft(e1)\n    ax1[1].plot(freq,np.abs(e1fft)**2)\n    ax1[1].set_xlim(0,0.1e16)\n    ax1[1].set_title('Espectro del campo')\n    ax1[1].vlines(omega/(2*np.pi),0,np.max(np.abs(e1fft)**2),'k')\n    return \n\ncampofft(time,omega,tau)\n"}
{"cell_type":"markdown","metadata":{},"source":"### ¿Qué ocurre si iluminamos el experimento de Young con este tipo de radiación?\n\nSi iluminamos una doble rendija con un tren de ondas como el representado anteriormente, tendremos dos ondas llegando a un cierto punto de la pantalla con la misma evolución temporal pero una de ellas retrasada con respecto a la otra. Esto es debido a la diferencia de camino óptico recorrido por cada tren de onda. \n\nCuando superponemos ambos trenes (uno con un cierto retraso con respecto al otro), la diferencia entre las fases iniciales de cada onda dependerá del tiempo. Además, como los saltos de fase en el tren de ondas son aleatorios, esa diferencia de fase cambiara a su vez aleatoriamente. El siguiente codigo muestra esta diferencia."}
{"cell_type":"markdown","metadata":{},"source":"Esta diferencia aleatoria tiene un gran efecto en la irradiancia total del patron de interferencias.\n\nRecordemos que la intensidad total viene dada por:\n\n$$ I_t  = I_1 + I_2 + \\epsilon_0 c n < E_1 E_2>_{\\tau}$$\n\nEn la anterior expresion hemos dejado explícitamente en el término interferencial el promedio sobre el producto escalar de los campos que interfieren. Este producto escalar nos da lugar a, \n\n$$\\int_0^\\tau \\cos(k_1 r - \\omega t + \\phi_1) \\cos(k_2 r - \\omega t + \\phi_2) dt$$\n\nque podemos escribir en función de la diferencia de fases iniciales  $\\phi_1 - \\phi_2$. Si esta diferencia varía aleatoriamente durante el intervalo de tiempo $\\tau$, su promedio sera nulo y el termino interferencial tambien lo sera. Por tanto la irradiancia total sera, \n\n$$I_t = I_1 + I_2$$\n\nEs decir, se pierden las franjas de interferencia. Esta situación ocurrirá cuando la diferencia de camino sea suficiente como para que no se solapen las zonas de los trenes de ondas que interfieren con la misma fase. Desde el centro de la pantalla (diferencia de fase igual a cero entre las ondas que interfieren) veremos entonces cómo las franjas se van perdiendo gradualmente a medida que nos alejamos a puntos exteriores (el contraste disminuye progresivamente) hasta que se pierden por completo (contraste igual a cero). En este punto, la irradiancia total será simplemente la suma de las irradiancias de los haces que interfieren.\n\nEl punto en el que las franjas se pierden por completo será, como se ha comentado, aquel que haga que no haya solapamiento entre las zonas de los trenes de ondas con la misma fase. Es decir, la diferencia de camino ha de ser mayor que la distancia característica de cada una de estas zonas. Esta distancia es simplemente la longitud de coherencia. Por tanto, perderemos la interferencia si, \n\n$$\\Delta > l_c$$\n\ndonde $\\Delta$ denota la diferencia de camino entre los haces.\n\nEl siguiente código muestra el patrón de interferencias cuando iluminamos el experimento de Young con un tren de ondas."}
{"cell_type":"code","execution_count":4,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"interfranja 0.5833333333333333 (mm)\nlongitud de coherencia 2.5 (um)\n"},{"name":"stderr","output_type":"stream","text":"/usr/lib/python3/dist-packages/matplotlib/collections.py:571: FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison\n  if self._edgecolors == str('face'):\n"},{"data":{"image/png":"smc-blob::371a426a-52dc-49b2-a93f-c56391c46ab1","text/plain":"<matplotlib.figure.Figure at 0x7ff0dfc32ba8>"},"metadata":{},"output_type":"display_data"}],"source":"from matplotlib.pyplot import *\nfrom numpy import *\n%matplotlib inline\nstyle.use('fivethirtyeight')\n\n#####\n#PARÁMETROS QUE SE PUEDEN MODIFICAR\n#####\nLambda = 5e-7 # longitud de onda de la radiación de 500 nm\nk = 2.0*pi/Lambda\nD = 3.5# en metros\na = 0.003 # separación entre fuentes de 3 mm\nDeltaLambda = 10e-8 # anchura espectral\n###########\n\nlc = (Lambda**2)/DeltaLambda\ninterfranja = Lambda*D/a\nprint (\"interfranja\",interfranja*1e3, \"(mm)\") # muestra el valor de la interfranja en mm\nprint( \"longitud de coherencia\", lc*1e6, \"(um)\") #muestra el valor de la long. de coherencia en um\n\nx = linspace(-10*interfranja,10*interfranja,500)\nI1 = 1 # Consideramos irradiancias normalizadas a un cierto valor.\nI2 = 1\n\nX,Y = meshgrid(x,x)\nDelta = a*X/D\ndelta = k*Delta\n\ngamma12 = (1 - np.abs(Delta)/lc)*(np.abs(Delta)<lc)\nItotal = I1 + I2 + 2.0*sqrt(I1*I2)*gamma12*cos(delta)\n\nfigure(figsize=(14,5))\nsubplot(121)\npcolormesh(x*1e3,x*1e3,Itotal,cmap = 'gray',vmin=0,vmax=4)\nxlabel(\"x (mm)\")\nylabel(\"y (mm)\")\nsubplot(122)\nplot(x*1e3,Itotal[(int)(x.shape[0]/2),:])\nxlim(-5,5)\nylim(0,4)\nxlabel(\"x (mm)\")\nylabel(\"Irradiancia total normalizada\");"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":""}